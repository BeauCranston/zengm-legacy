// @flow

import _ from 'underscore';
import {PHASE, PLAYER, g, helpers} from '../../common';
import {finances, league, phase, player, season} from '../core';
import {idb} from '../db';
import {local, logEvent, random, updatePlayMenu, updatePhase} from '../util';
import type {Conditions, PickRealized, TeamFiltered} from '../../common/types';

// Add a new set of draft picks
async function genPicks(season: number) {
    for (let tid = 0; tid < g.numTeams; tid++) {
        for (let round = 1; round <= 2; round++) {
            await idb.cache.draftPicks.add({
                tid,
                originalTid: tid,
                round,
                season,
            });
        }
    }
}

/**
 * Retrieve the current remaining draft order.
 *
 * @memberOf core.draft
 * @return {Promise} Resolves to an ordered array of pick objects.
 */
async function getOrder() {
	
	// save draft order to draftOrder or schedule?
	// use draft order could be seemless
	
    const row = await idb.cache.draftOrder.get(0);
//	console.log(row);
    return row.draftOrder;
}

/**
 * Save draft order for future picks to the database.
 *
 * @memberOf core.draft
 * @param {Array.<Object>} draftOrder Ordered array of pick objects, as generated by genOrder.
 * @return {Promise}
 */
async function setOrder(draftOrder: PickRealized[]) {
    await idb.cache.draftOrder.put({
        rid: 0,
        draftOrder,
    });
}

/**
 * Generate a set of draft prospects.
 *
 * This is called after draft classes are moved up a year, to create the new UNDRAFTED_3 class. It's also called 3 times when a new league starts, to create all 3 draft classes.
 *
 * @memberOf core.draft
 * @param {number} tid Team ID number for the generated draft class. Should be PLAYER.UNDRAFTED, PLAYER.UNDRAFTED_2, or PLAYER.UNDRAFTED_3.
 * @param {?number=} scoutingRank Between 1 and g.numTeams, the rank of scouting spending, probably over the past 3 years via core.finances.getRankLastThree. If null, then it's automatically found.
 * @param {?number=} numPlayers The number of prospects to generate. Default value is 70.
 * @return {Promise}
 */
async function genPlayers(tid: number, scoutingRank?: ?number = null, numPlayers?: number, newLeague?: boolean = false,cDefault,topADC,topMID,topJGL,topTOP,topSUP) {

	
    if (numPlayers === null || numPlayers === undefined) {
//        numPlayers = Math.round(70 * g.numTeams / 30); // 70 scaled by number of teams
        numPlayers = Math.round(70 * g.numTeams / 30 ) * 1.5 * g.prospectSupply; // 70 scaled by number of teams
//        numPlayers = Math.round(70 * g.numTeams / 30 * 3); // 70 scaled by number of teams
		//numPlayers = Math.round(g.numTeams * 8 * 3 / 5);
    }

    // If scoutingRank is not supplied, have to hit the DB to get it
    if (scoutingRank === undefined || scoutingRank === null) {
        const teamSeasons = await idb.cache.teamSeasons.indexGetAll('teamSeasonsByTidSeason', [`${g.userTid},${g.season - 2}`, `${g.userTid},${g.season}`]);
        scoutingRank = finances.getRankLastThree(teamSeasons, "expenses", "scouting");
    }

    const profiles = ["Point", "Wing", "Big", "Big", ""];

	let baseRating;
	let pot;	
    for (let i = 0; i < numPlayers; i++) {
		
		if (g.gameType == 1 || g.gameType == 6) {
			baseRating = random.randInt(0, 32);					
			pot = Math.round(helpers.bound(random.realGauss(17, 55), baseRating, 100)); // 9 SUP										
		} else {
			baseRating = random.randInt(0, 32);					
			pot = Math.round(helpers.bound(random.realGauss(17, 55), baseRating, 100)); // 9 SUP										
		}		
		
        //const baseRating = random.randInt(8, 31);
        //const pot = Math.round(helpers.bound(random.realGauss(48, 17), baseRating, 90));

        const profile = profiles[random.randInt(0, profiles.length - 1)];
        //const agingYears = random.randInt(0, 3);
		const agingYears = 0;
        let draftYear = g.season;

        let baseAge = 17;
        if (newLeague) {
            // New league, creating players for draft in same season and following 2 seasons
            if (tid === PLAYER.UNDRAFTED_2) {
                baseAge -= 1;
                draftYear += 1;
            } else if (tid === PLAYER.UNDRAFTED_3) {
                baseAge -= 2;
                draftYear += 2;
            }
        } else if (tid === PLAYER.UNDRAFTED_3) {
            // Player being generated after draft ends, for draft in 3 years
            baseAge -= 3;
            draftYear += 3;
        }

	
		//console.log(cDefault);
//		console.log(topADC);
		

        const p = player.generate(tid, baseAge, profile, baseRating, pot, draftYear, false, scoutingRank, cDefault,topADC,topMID,topJGL,topTOP,topSUP);
        player.develop(p, agingYears, true, null,topADC,topMID,topJGL,topTOP,topSUP);

        // Update player values after ratings changes
        await player.updateValues(p);
        await idb.cache.players.add(p);
    }
}

function lotteryLogTxt(tid: number, type: 'chance' | 'moveddown' | 'movedup' | 'normal', number: number) {
    let txt = `The <a href="${helpers.leagueUrl(["roster", g.teamAbbrevsCache[tid], g.season])}">${g.teamNamesCache[tid]}</a>`;
    if (type === 'chance') {
        txt += ` have a ${number.toFixed(2)}% chance of getting the top overall pick of the ${g.season} draft.`;
    } else if (type === 'movedup') {
        txt += ` moved up in the lottery and will select ${helpers.ordinal(number)} overall in the ${g.season} draft.`;
    } else if (type === 'moveddown') {
        txt += ` moved down in the lottery and will select ${helpers.ordinal(number)} overall in the ${g.season} draft.`;
    } else if (type === 'normal') {
        txt += ` will select ${helpers.ordinal(number)} overall in the ${g.season} draft.`;
    }
    return txt;
}

function logAction(tid: number, text: string, conditions: Conditions) {
    logEvent({
        type: "draft",
        text,
        showNotification: tid === g.userTid,
        pids: [],
        tids: [tid],
    }, conditions);
}

function logLotteryChances(chances: number[], teams: TeamFiltered[], draftOrder, conditions: Conditions) {
    for (let i = 0; i < chances.length; i++) {
        if (i < teams.length) {
            const origTm = teams[i].tid;
            const tm = draftOrder[origTm][1].tid;
            const txt = lotteryLogTxt(tm, 'chance', chances[i]);
            logAction(tm, txt, conditions);
        }
    }
}

function logLotteryWinners(chances: number[], teams: TeamFiltered[], tm: number, origTm: number, pick: number, conditions: Conditions) {
    const idx = teams.find(t => t.tid === origTm);
    if (idx !== undefined) {
        let txt;
        if (chances[idx] < chances[pick - 1]) {
            txt = lotteryLogTxt(tm, 'movedup', pick);
        } else if (chances[idx] > chances[pick - 1]) {
            txt = lotteryLogTxt(tm, 'moveddown', pick);
        } else {
            txt = lotteryLogTxt(tm, 'normal', pick);
        }
        logAction(tm, txt, conditions);
    }
}

/**
 * Divide the combinations between teams with tied records.
 *
 * If isFinal is true, the remainder value is distributed randomly instead
 * of being set as a decimal value on the result.
 */
function updateChances(chances: number[], teams: TeamFiltered[], isFinal?: boolean = false) {
    let wps = _.countBy(teams, (t) => t.seasonAttrs.winp);
    wps = _.pairs(wps);
    wps = _.sortBy(wps, x => Number(x[0]));
    let tc = 0;

    for (let k = 0; k < wps.length; k++) {
        let val = wps[k][1];
        if (val > 1) {
            if (tc + val >= chances.length) {
                val -= (tc + val - chances.length);
                // Do not exceed 14, as the chances are only for lottery teams.
            }
            const total = chances.slice(tc, tc + val).reduce((a, b) => a + b);
            let remainder = (isFinal) ? total % val : 0;
            const newVal = (total - remainder) / val;

            let i;
            let j;
            for (i = tc, j = tc + val; i < j; i++) {
                chances[i] = newVal;
                if (remainder > 0) {
                    chances[i] += 1;
                    remainder--;
                }
            }
        }
        tc += val;
        if (tc >= chances.length) {
            break;
        }
    }
}

/**
 * Sort teams in place in correct order for lottery.
 *
 * Sort teams by making playoffs (NOT playoff performance) and winp, for first round
 */
function lotterySort(teams: TeamFiltered[]) {
    /**
     * http://www.nba.com/2015/news/04/17/2015-draft-order-of-selection-tiebreak-official-release/index.html
     *
     * The tiebreaker used after the lottery is random. Which is then reversed for the 2nd round.
     */
    const randValues = _.range(g.numTeams);
    random.shuffle(randValues);
    for (let i = 0; i < teams.length; i++) {
        teams[i].randVal = randValues[i];
    }

    teams.sort((a, b) => {
        let r;
        r = 0;
        if ((a.seasonAttrs.playoffRoundsWon >= 0) && !(b.seasonAttrs.playoffRoundsWon >= 0)) {
            r = 1;
        }
        if (!(a.seasonAttrs.playoffRoundsWon >= 0) && (b.seasonAttrs.playoffRoundsWon >= 0)) {
            r = -1;
        }

        r = (r === 0) ? a.seasonAttrs.winp - b.seasonAttrs.winp : r;
        r = (r === 0) ? a.randVal - b.randVal : r;
        return r;
    });
}

/**
 * Sets draft order and save it to the draftOrder object store.
 *
 * This is currently based on an NBA-like lottery, where the first 3 picks can be any of the non-playoff teams (with weighted probabilities).
 *
 * @memberOf core.draft
 * @return {Promise}
 */
//async function genOrder(game, conditions: Conditions) {
function genOrder(game, conditions: Conditions) {
	
	// call this during prep to game
	// put draft picks in this instead of draft page
  //  const games = helpers.deepCopy(await season.getSchedule(true));
// get user's game, then populate pick ban section with it. 
// make it known which rows are picks and which are bans.
// may have to reorganize page.
// 4 sections, team A bans, teams B bans, team A picks, team B picks
// Could even display each in a special way

console.log("genOrder");
	let usersGame = {};
	let undrafted = [];
	let drafted = [];	
	
	usersGame = helpers.deepCopy(game);

	
	
	/*drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 1,
			pick: "BAN",
		},
		pid: -1,
	});
	 drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 1,
			pick: "BAN",
		},
		pid: -1,
	});	
	 drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 2,
			pick: "BAN",
		},
		pid: -1,
	});		
	 drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 2,
			pick: "BAN",
		},
		pid: -1,
	});				

	drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 3,
			pick: "BAN",
		},
		pid: -1,
	});
	drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 3,
			pick: "BAN",
		},
		pid: -1,
	});	
	 drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 1,
			pick: "PICK",
		},
		pid: -1,
	});		
	 drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 1,
			pick: "PICK",
		},
		pid: -1,
	});			
	 drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 2,
			pick: "PICK",
		},
		pid: -1,
	});	
	 drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 2,
			pick: "PICK",
		},
		pid: -1,
	});
	drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 3,
			pick: "PICK",
		},
		pid: -1,
	});			
	drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 3,
			pick: "PICK",
		},
		pid: -1,
	});		
	drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 4,
			pick: "BAN",
		},
		pid: -1,
	});	
	drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 4,
			pick: "BAN",
		},
		pid: -1,
	});
	drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 5,
			pick: "BAN",
		},
		pid: -1,
	});		
	drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 5,
			pick: "BAN",
		},
		pid: -1,
	});
	drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 4,
			pick: "PICK",
		},
		pid: -1,
	});	
	drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 4,
			pick: "PICK",
		},
		pid: -1,
	});		
	drafted.push({
		draft: {
			tid: usersGame.homeTid,
			originalTid: usersGame.homeTid,				
			round: 5,
			pick: "PICK",
		},
		pid: -1,
	});			

	drafted.push({
		draft: {
			tid: usersGame.awayTid,
			originalTid: usersGame.awayTid,				
			round: 5,
			pick: "PICK",
		},
		pid: -1,
	});		*/
	
	


//    await setOrder(draftOrder);
    //await setOrder(drafted);
	usersGame.draftpicks = drafted;
//	return drafted;
	return usersGame ;
}

/**
 * Sets fantasy draft order and save it to the draftOrder object store.
 *
 * Randomize team order and then snake for 12 rounds.
 *
 * @memberOf core.draft
 * @return {Promise}
 */
async function genOrderFantasy(position: number) {
    // Randomly-ordered list of tids
    const tids = _.range(g.numTeams);
    random.shuffle(tids);
    if (position !== undefined && position >= 1 && position <= g.numTeams) {
        let i = 0;
        while (tids[position - 1] !== g.userTid && i < 1000) {
            random.shuffle(tids);
            i += 1;
        }
    }

    // Set total draft order: 8 rounds, snake
    const draftOrder = [];
    for (let round = 1; round <= 8; round++) {
        for (let i = 0; i < tids.length; i++) {
            draftOrder.push({
                round,
                pick: i + 1,
                tid: tids[i],
                originalTid: tids[i],
            });
        }

        tids.reverse(); // Snake
    }

    await setOrder(draftOrder);
}

/**
 * Get a list of rookie salaries for all players in the draft.
 *
 * By default there are 60 picks, but some are added/removed if there aren't 30 teams.
 *
 * @memberOf core.draft
 * @return {Array.<number>} Array of salaries, in thousands of dollars/year.
 */
function getRookieSalaries(): number[] {
    // Default for 60 picks
    const rookieSalaries = [5000, 4500, 4000, 3500, 3000, 2750, 2500, 2250, 2000, 1900, 1800, 1700, 1600, 1500, 1400, 1300, 1200, 1100, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500];

    while (g.numTeams * 2 > rookieSalaries.length) {
        // Add min contracts on to end
        rookieSalaries.push(500);
    }
    while (g.numTeams * 2 < rookieSalaries.length) {
        // Remove smallest salaries
        rookieSalaries.pop();
    }

    if (g.minContract !== 500 || g.maxContract !== 20000) {
        for (let i = 0; i < rookieSalaries.length; i++) {
            // Subtract min
            rookieSalaries[i] -= 500;

            // Scale so max will be 1/4 the max contract
            rookieSalaries[i] *= (0.25 * g.maxContract - g.minContract) / (4500);

            // Add min back
            rookieSalaries[i] += g.minContract;

            rookieSalaries[i] = Math.round(rookieSalaries[i] / 10) * 10;
        }
    }

    return rookieSalaries;
}

/**
 * Select a player for the current drafting team.
 *
 * This can be called in response to the user clicking the "draft" button for a player, or by some other function like untilUserOrEnd.
 *
 * @memberOf core.draft
 * @param {object} pick Pick object, like from getOrder, that contains information like the team, round, etc.
 * @param {number} pid Integer player ID for the player to be drafted.
 * @return {Promise}
 */
async function selectPlayer(pick: PickRealized, pid: number) {
	
	console.log("selectPlayer");
    const p = await idb.cache.players.get(pid);

    // Draft player
    p.tid = pick.tid;
    if (g.phase !== g.PHASE.FANTASY_DRAFT) {
        p.draft = {
            round: pick.round,
            pick: pick.pick,
            tid: pick.tid,
            year: g.season,
            originalTid: pick.originalTid,
            pot: p.ratings[0].pot,
            ovr: p.ratings[0].ovr,
            skills: p.ratings[0].skills,
        };
    }

    // Contract
    if (g.phase !== g.PHASE.FANTASY_DRAFT) {
        const rookieSalaries = getRookieSalaries();
        const i = pick.pick - 1 + g.numTeams * (pick.round - 1);
        const years = 4 - pick.round; // 2 years for 2nd round, 3 years for 1st round;
        player.setContract(p, {
            amount: rookieSalaries[i],
            exp: g.season + years,
        }, true);
    }

    // Add stats row if necessary (fantasy draft in ongoing season)
    if (g.phase === g.PHASE.FANTASY_DRAFT && g.nextPhase <= g.PHASE.PLAYOFFS) {
        await player.addStatsRow(p, (g.nextPhase === g.PHASE.PLAYOFFS || g.nextPhase === g.PHASE.MSI ));
    }

    await idb.cache.players.put(p);

    idb.cache.markDirtyIndexes('players');

    const draftName = g.phase === g.PHASE.FANTASY_DRAFT ? `${g.season} fantasy draft` : `${g.season} draft`;
    logEvent({
        type: "draft",
        text: `The <a href="${helpers.leagueUrl(["roster", g.teamAbbrevsCache[pick.tid], g.season])}">${g.teamNamesCache[pick.tid]}</a> selected <a href="${helpers.leagueUrl(["player", p.pid])}">${p.firstName} ${p.lastName}</a> with the ${helpers.ordinal(pick.pick + (pick.round - 1) * 30)} pick in the <a href="${helpers.leagueUrl(["draft_summary", g.season])}">${draftName}</a>.`,
        showNotification: false,
        pids: [p.pid],
        tids: [p.tid],
    });
}

async function selectPlayerFantasy(pick: PickRealized, pid: number) {
    const p = await idb.cache.players.get(pid);

    // Draft player
///	console.log("selectPlayer");	
//	console.log(pick.tid);		
    p.tid = pick.tid;
 /*   if (g.phase !== PHASE.FANTASY_DRAFT) {
		console.log("selectPlayer");
		p.draft = {
				round: pick.round,
				pick: pick.pick,
				tid: pick.tid,
				year: g.season,
				originalTid: pick.originalTid,
				pot: p.ratings[0].pot,
				ovr: p.ratings[0].ovr,
				skills: p.ratings[0].skills,
			};
    }

    // Contract
    if (g.phase !== PHASE.FANTASY_DRAFT) {
			console.log("selectPlayer");
        const rookieSalaries = getRookieSalaries();
        const i = pick.pick - 1 + g.numTeams * (pick.round - 1);
        const years = 4 - pick.round; // 2 years for 2nd round, 3 years for 1st round;
        player.setContract(p, {
            amount: rookieSalaries[i],
            exp: g.season + years,
        }, true);
    }*/

    // Add stats row if necessary (fantasy draft in ongoing season)
    if (g.phase === PHASE.FANTASY_DRAFT && g.nextPhase <= PHASE.PLAYOFFS) {
        await player.addStatsRow(p, g.nextPhase === PHASE.PLAYOFFS);
    }

//	console.log(p);
    await idb.cache.players.put(p);

    idb.cache.markDirtyIndexes('players');

    const draftName = g.phase === PHASE.FANTASY_DRAFT ? `${g.season} fantasy draft` : `${g.season} draft`;
    logEvent({
        type: "draft",
        text: `The <a href="${helpers.leagueUrl(["roster", g.teamAbbrevsCache[pick.tid], g.season])}">${g.teamNamesCache[pick.tid]}</a> selected <a href="${helpers.leagueUrl(["player", p.pid])}">${p.firstName} ${p.lastName}</a> with the ${helpers.ordinal(pick.pick + (pick.round - 1) * 30)} pick in the <a href="${helpers.leagueUrl(["draft_summary", g.season])}">${draftName}</a>.`,
        showNotification: false,
        pids: [p.pid],
        tids: [p.tid],
    });
}

async function untilUserOrEndFantasy(conditions: Conditions) {
    const pids = [];

    const [playersAll, draftOrder] = await Promise.all([
        idb.cache.players.indexGetAll('playersByTid', PLAYER.UNDRAFTED),
        getOrder(),
    ]);

    playersAll.sort((a, b) => b.value - a.value);

    // Called after either the draft is over or it's the user's pick
    const afterDoneAutoFantasy = async () => {
        await setOrder(draftOrder);

        // Is draft over?
		//console.log(draftOrder.length);
        if (draftOrder.length === 0) {
            // Fantasy draft special case!
		//	console.log(g.phase);
		//	console.log(PHASE.FANTASY_DRAFT);
			
           // if (g.phase === PHASE.FANTASY_DRAFT) {
                // Undrafted players become free agents
                const baseMoods = await player.genBaseMoods();
                const playersUndrafted = await idb.cache.players.indexGetAll('playersByTid', PLAYER.UNDRAFTED);
                for (const p of playersUndrafted) {				
                    await player.addToFreeAgents(p, PHASE.FREE_AGENCY, baseMoods);
                }

                // Swap back in normal draft class
                const players = await idb.cache.players.indexGetAll('playersByTid', PLAYER.UNDRAFTED_FANTASY_TEMP);
                for (const p of players) {
                    p.tid = PLAYER.UNDRAFTED;
                    await idb.cache.players.put(p);
                }

                idb.cache.markDirtyIndexes('players');

                await league.setGameAttributes({
                    phase: g.nextPhase,
                    nextPhase: null,
                });

                await updatePhase();
                await updatePlayMenu();
				//console.log("END FANTASY DRAFT");
           // } else {
                // Non-fantasy draft
           //     await phase.newPhase(PHASE.AFTER_DRAFT, conditions);
          //  }
        }

        // Draft is not over, so continue
        return pids;
    };

    // This will actually draft "untilUserOrEnd"
    const autoSelectPlayerFantasy = async () => {
	//	console.log(draftOrder);
	//	console.log(draftOrder.length);
        if (draftOrder.length > 0) {
            const pick = draftOrder.shift();

		   const t = await idb.getCopy.teamsPlus({
				attrs: ["region","country","countrySpecific"],
				seasonAttrs: ["imgURLCountry","countrySpecific"],
//				stats: ["gp"],
				season: g.season,
				tid: pick.tid,
			});
			//console.log(t);
			//console.log(t.country);			
            if (g.userTids.includes(pick.tid) && local.autoPlaySeasons === 0) {
                draftOrder.unshift(pick);
                return afterDoneAutoFantasy();
            }

			//console.log(playersAll[0].ratings[0].region);
			//console.log(playersAll.length);
			//console.log(pick);
			let selection;
			for (let i = 0; i < playersAll.length; i++) {
			///	console.log(playersAll.length+" "+i+" "+playersAll[i].ratings[0].region+" "+t.country);
				selection = i;				
				if (playersAll[i].ratings[0].region == t.country) {
					// can have 1-2 imports, need ot think about this more
					//if (Math.random() > .15) {
					//	console.log(t.country);			
					//	console.log(playersAll[i].ratings[0].region);
						
						//selection = i;
						break;
					//}
				}

			}

      //      const selection = Math.floor(Math.abs(random.gauss(0, 2))); // 0=best prospect, 1=next best prospect, etc.
            const pid = playersAll[selection].pid;
			//console.log(pick);
			//console.log(pick.tid);			
			//console.log(selection);
			//console.log(playersAll[selection]);
            await selectPlayerFantasy(pick, pid);
            pids.push(pid);
			//console.log(playersAll[selection]);
            playersAll.splice(selection, 1); // Delete from the list of undrafted players

            return autoSelectPlayerFantasy();
        }

        return afterDoneAutoFantasy();
    };

    return autoSelectPlayerFantasy();
}

// checks position of player and champion, adjust player champ value to almost 0 if champ doesn't fil player's role
async function champDraftValues(championRank, champions, players, i, conditions: Conditions) {
			var idealPosition;
			var position, adjustment,topRanked;

		//	console.log(championRank); // patch  championRank[iv].rank
		//	console.log(champions); // champ
			// champions[ii].counter[iii]
			// champions[ii].synergy[iii]			
	//		console.log(players);	// players.champion[i].skill		
			//console.log(i);
           let rating = players[i].ratings.find(r => r.season === g.season);
			//console.log(rating);
            if (rating === undefined) {
                // Sometimes this happens for unknown reasons, so gracefully handle it
                rating = players[i].ratings[players[i].ratings.length - 1];
            }
		
			/*if (players[i].pos == "JGL") {
			   position = "Jungle";
			} else 	if (players[i].pos == "SUP") {
			   position = "Support";
			} else 	if (players[i].pos == "MID") {
			   position = "Middle";
			} else 	if (players[i].pos == "TOP") {
			   position = "Top";
			} else {*/
			//}
			
			// need to change all player position to SAFE OFF for DOTA 2 champions?
			// if so, then this will need to be changed as well
			
			if (g.champType == 0) {
			   position = players[i].pos;
				
				if (i==0) {
					idealPosition = "TOP";
				} else if (i==1) {
					idealPosition = "JGL";
				} else if (i==2) {
					idealPosition = "MID";
				} else if (i==3) {
					idealPosition = "ADC";
				} else if (i==4) {
					idealPosition = "SUP";
				}	
///console.log(position+" "+idealPosition);				
			}	else {
				if (players[i].pos == "JGL") {
				   position = "OFF";
				} else 	if (players[i].pos == "SUP") {
				   position = "SUP";
				} else 	if (players[i].pos == "MID") {
				   position = "MID";
				} else 	if (players[i].pos == "TOP") {
				   position = "OFF";
				} else {
				   position = "SAFE";				
				}	

				
				if (i==0) {
					idealPosition = "OFF";
				} else if (i==1) {
					idealPosition = "OFF";
				} else if (i==2) {
					idealPosition = "MID";
				} else if (i==3) {
					idealPosition = "SAFE";
				} else if (i==4) {
					idealPosition = "SAFE";
				}						
			}
				
		//console.log(players[i]);
	//	console.log(players[i].userID+" "+i+" "+idealPosition+" "+position);
			if (idealPosition ==  position) {
				adjustment = 1.00;
			} else {
				adjustment = 0.10;							  
			}					
		
		//	console.log(champions.length);
			let playerChamps = true;
			if (players[i].champions == undefined) {
				players[i].champions = [];
				//playerChamps = 
			}
			//console.log(players[i].champions);
			
			for (let j = 0; j < champions.length; j++) { // champions
			//console.log(j+" "+i+" "+players[i].championAverage+" "+players[i].champions[j].skill);
			//	console.log(players[i].champions[j].draftValue+" "+players[i].championAverage+" "+players[i].champions[j].skill);
				if (players[i].champions[j] == undefined) {
					players[i].champions[j] = {};
					players[i].champions[j].draftValue =  .50;	
					players[i].champions[j].name = champions[j].name;					
				//console.log("got here");
				} else if ( (players[i].championAverage == -1) || (players[i].championAverage == undefined)) {

					players[i].champions[j].draftValue =  (players[i].champions[j].skill)/100;		
					
				//	console.log(i+" "+j+" "+players[i].champions[j].skill+" "+players[i].champions[j].draftValue)					
//				console.log("got here");			
				} else {						
					players[i].champions[j].draftValue =  Number(players[i].championAverage)/100;							
			//	console.log("got here");				
				}
				//console.log(players[i].champions[j].draftValue);
//				topRanked = championPatch.length;
//				topRanked = championRank.length;

				topRanked = 0.00;
				let cpid = 0;				
				for (let r = 0; r < championRank.length; r++) {		// patch
//				for (let r = 0; r < championPatch.length; r++) {

					if (players[i].champions[j].name == championRank[r].champion) {
//						if (position == championRank[r].role)) {
						if (idealPosition == championRank[r].role) {
					//	console.log(players[i].champions[j].name+" "+championRank[r].champion+" "+position+" "+championRank[r].role);
					//	console.log(championRank[r].rank+" "+topRanked);
						  if  (championRank[r].rank > topRanked) {
								topRanked = championRank[r].rank;
								cpid = r;
						//		console.log(topRanked+" "+r);								
								// wrong match between cpid and champion role?
								
								// impact of player champ ability and champ win rate?
								// put in a variable here that can be adjusted in god mode?
								// make impact %10 on win rate?
								//console.log(i+" "+j+" "+g.playerChampRatingImpact+" "+topRanked+" "+adjustment+" "+players[i].champions[j].draftValue);
								
								players[i].champions[j].draftValue *= g.playerChampRatingImpact; // range from 1 to .5, or same to double
								//console.log(i+" "+j+" "+g.playerChampRatingImpact+" "+topRanked+" "+adjustment+" "+players[i].champions[j].draftValue);
								players[i].champions[j].draftValue += Number(topRanked); // range from 1 to .5, or same to double
							//	console.log(i+" "+j+" "+g.playerChampRatingImpact+" "+topRanked+" "+adjustment+" "+players[i].champions[j].draftValue);
								// if not playing position adjustment will make champ win rate + player skill almost 0, putting the team at a big disadvantage
								players[i].champions[j].draftValue *= adjustment; // range from 1 to .5, or same to double
								//console.log(i+" "+j+" "+g.playerChampRatingImpact+" "+topRanked+" "+adjustment+" "+players[i].champions[j].draftValue);
								
								players[i].champions[j].cpid = cpid; // range from 1 to .5, or same to double
								players[i].champions[j].hid = j; // range from 1 to .5, or same to double
								players[i].champions[j].role = position; // range from 1 to .5, or same to double
								//console.log(i+" "+j+" "+players[i].champions[j].draftValue);
						//		console.log(players[i].champions[j].name+" "+position+" "+topRanked+" "+players[i].champions[j].draftValue+" "+players[i].champions[j].cpid);
								
						  }				   
						}
				   } 
				}
				//console.log(players[i].champions[j].draftValue);				
//				if (topRanked == championRank.length) {
				if (topRanked == 0.00) {
//					players[i].champions[j].draftValue *= adjustment; // range from 1 to .5, or same to double
					players[i].champions[j].draftValue *= g.playerChampRatingImpact; // range from 1 to .5, or same to double
					players[i].champions[j].cpid = ""; // range from 1 to .5, or same to double
					//console.log(players[i].champions[j].name+" "+position+" "+topRanked+" "+players[i].champions[j].draftValue+" "+players[i].champions[j].cpid);
					
				} 
				
				
			}			
		//	console.log(players[i].champions);
	//	console.log(players[i]);			
			players[i].champions.length = champions.length;	
			//console.log(players[i].champions);
			return players;
}	


async function setDraftOrder(drafted, usersGame, conditions: Conditions) {

			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 1,
					pick: "BAN",
				},
				pid: -1,
			});
			 drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 1,
					pick: "BAN",
				},
				pid: -1,
			});	
			 drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 2,
					pick: "BAN",
				},
				pid: -1,
			});		
			 drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 2,
					pick: "BAN",
				},
				pid: -1,
			});				

			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 3,
					pick: "BAN",
				},
				pid: -1,
			});
			drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 3,
					pick: "BAN",
				},
				pid: -1,
			});	
			 drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 1,
					pick: "PICK",
				},
				pid: -1,
			});		
			 drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 1,
					pick: "PICK",
				},
				pid: -1,
			});			
			 drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 2,
					pick: "PICK",
				},
				pid: -1,
			});	
			 drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 2,
					pick: "PICK",
				},
				pid: -1,
			});
			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 3,
					pick: "PICK",
				},
				pid: -1,
			});			
			drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 3,
					pick: "PICK",
				},
				pid: -1,
			});		
			drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 4,
					pick: "BAN",
				},
				pid: -1,
			});	
			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 4,
					pick: "BAN",
				},
				pid: -1,
			});
			drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 5,
					pick: "BAN",
				},
				pid: -1,
			});		
			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 5,
					pick: "BAN",
				},
				pid: -1,
			});
			drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 4,
					pick: "PICK",
				},
				pid: -1,
			});	
			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 4,
					pick: "PICK",
				},
				pid: -1,
			});		
			drafted.push({
				draft: {
					tid: usersGame.homeTid,
					originalTid: usersGame.homeTid,				
					round: 5,
					pick: "PICK",
				},
				pid: -1,
			});			

			drafted.push({
				draft: {
					tid: usersGame.awayTid,
					originalTid: usersGame.awayTid,				
					round: 5,
					pick: "PICK",
				},
				pid: -1,
			});	

			//console.log(players[i].champions);
			return drafted;
}	

/**
 * Simulate draft picks until it's the user's turn or the draft is over.
 *
 * This could be made faster by passing a transaction around, so all the writes for all the picks are done in one transaction. But when calling selectPlayer elsewhere (i.e. in testing or in response to the user's pick), it needs to be sure that the transaction is complete before continuing. So I would need to create a special case there to account for it. Given that this isn't really *that* slow now, that probably isn't worth the complexity. Although... team.rosterAutoSort does precisely this... so maybe it would be a good idea...
 *
 * @memberOf core.draft
 * @return {Promise.[Array.<Object>, Array.<number>]} Resolves to array. First argument is the list of draft picks (from getOrder). Second argument is a list of player IDs who were drafted during this function call, in order.
 */
async function untilUserOrEnd(conditions: Conditions) {

		console.log("untilUserOrEnd");
		console.log("this picks for AI");
	/// need to update this
    const pids = [];

    const [playersAll, draftOrder, schedule] = await Promise.all([
        idb.cache.players.indexGetAll('playersByTid', PLAYER.UNDRAFTED),
        getOrder(),
		await idb.cache.schedule.getAll()	
    ]);

	console.log(playersAll);
	console.log(draftOrder);
	console.log(schedule);
	var usersGame;
	var userGame,i;
	console.log(schedule.length);
	// check schedule for next draft location
	for ( i = 0; i < schedule.length; i++) {
		console.log(i+" "+schedule[i].homeTid+" "+schedule[i].awayTid+" "+g.userTid);
		if (schedule[i].homeTid == g.userTid || schedule[i].awayTid == g.userTid) {
			usersGame = helpers.deepCopy(schedule[i]);
			userGame = true;	
	console.log(userGame);
			break;		
		}
	}	
	console.log(usersGame);
	console.log(draftOrder);
	var round;
	for ( i = 0; i < 20; i++) {
		if (usersGame.champions.drafted[i].name == undefined) {
			round = i;
			break;		
		}
		round = 20;
	}		
		
	
    playersAll.sort((a, b) => b.value - a.value);

    // Called after either the draft is over or it's the user's pick
    const afterDoneAuto = async () => {
		console.log(draftOrder);
        await setOrder(draftOrder);

        // Is draft over?
//        if (draftOrder.length === 0) {
        if (round == 20) {
            // Fantasy draft special case!
            if (g.phase === g.PHASE.FANTASY_DRAFT) {
                // Undrafted players become free agents
                const baseMoods = await player.genBaseMoods();
                const playersUndrafted = await idb.cache.players.indexGetAll('playersByTid', PLAYER.UNDRAFTED);
                for (const p of playersUndrafted) {
                    await player.addToFreeAgents(p, g.PHASE.FREE_AGENCY, baseMoods);
                }

                // Swap back in normal draft class
                const players = await idb.cache.players.indexGetAll('playersByTid', PLAYER.UNDRAFTED_FANTASY_TEMP);
                for (const p of players) {
                    p.tid = PLAYER.UNDRAFTED;
                    await idb.cache.players.put(p);
                }

                idb.cache.markDirtyIndexes('players');

                await league.setGameAttributes({
                    phase: g.nextPhase,
                    nextPhase: null,
                });

                await updatePhase();
                await updatePlayMenu();
            } else {
                // Non-fantasy draft
              //  await phase.newPhase(g.PHASE.AFTER_DRAFT, conditions);
			  // put play games here?
            }
        }
		console.log(pids);
        // Draft is not over, so continue
        return pids;
    };

    // This will actually draft "untilUserOrEnd"
    const autoSelectPlayer = async () => {
		
		/////////////// this is where to put the pick/ban logic
	console.log("autoSelectPlayer");
		console.log(round);
		console.log(schedule);		
		console.log(usersGame);		
		
        //if (draftOrder.length > 0) {
        if (round < 20) {			
			
         //   const pick = draftOrder.shift();
		//console.log(pick);
        /*    if (g.userTids.includes(pick.tid) && local.autoPlaySeasons === 0) {
                draftOrder.unshift(pick);
    console.log("return afterDoneAuto();");				
                return afterDoneAuto();
            }*/

          /*  const selection = Math.floor(Math.abs(random.gauss(0, 2))); // 0=best prospect, 1=next best prospect, etc.
            const pid = playersAll[selection].pid;
            await selectPlayer(pick, pid);
            pids.push(pid);
            playersAll.splice(selection, 1); // Delete from the list of undrafted players
    console.log("return autoSelectPlayer();");
            return autoSelectPlayer();*/
			round += 1;
			return autoSelectPlayer();
			//return;
        }
    console.log("return afterDoneAuto();");
        return afterDoneAuto();
    };
    console.log("return autoSelectPlayer();");
    return autoSelectPlayer();
}

export default {
    genPicks,
    getOrder,
    setOrder,
    genPlayers,
    genOrder,
    genOrderFantasy,
    untilUserOrEnd,
	untilUserOrEndFantasy,
    getRookieSalaries,
    selectPlayer,
    selectPlayerFantasy,	
    updateChances,
    lotterySort,
	champDraftValues,
	setDraftOrder,
};
